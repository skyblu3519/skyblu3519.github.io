<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ç”¨ChatGPTå¼€å‘ä¸€ä¸ªæ™ºèƒ½èœœç½ | skkyblu3</title>
<link rel="shortcut icon" href="https://skyblu3519.github.io/favicon.ico?v=1721054258675">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://skyblu3519.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="ç”¨ChatGPTå¼€å‘ä¸€ä¸ªæ™ºèƒ½èœœç½ | skkyblu3 - Atom Feed" href="https://skyblu3519.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="æ¥ç”¨ChatGPTåšä¸ªèœœç½ï¼Œhave fun~ğŸ˜
æç¤ºè¯å·¥ç¨‹ï¼ˆPrompt Engineeringï¼‰
æ•™ç¨‹BVå·ï¼šBV1No4y1t7Zn
ç¼–å†™åŸåˆ™ï¼š

ç¼–å†™æ˜ç¡®å’Œå…·ä½“çš„æŒ‡ä»¤
ç»™æ¨¡å‹è¶³å¤Ÿçš„æ—¶é—´æ€è€ƒ

ä¸€ä¸ªPromptçš„æ ·ä¾‹ï¼š
import..." />
    <meta name="keywords" content="ChatGPT,èœœç½,Prompt Engineering" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://skyblu3519.github.io">
  <img class="avatar" src="https://skyblu3519.github.io/images/avatar.png?v=1721054258675" alt="">
  </a>
  <h1 class="site-title">
    skkyblu3
  </h1>
  <p class="site-description">
    Welcome to Internet
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          é¦–é¡µ
        </a>
      
    
      
        <a href="/archives" class="menu">
          å½’æ¡£
        </a>
      
    
      
        <a href="/tags" class="menu">
          æ ‡ç­¾
        </a>
      
    
      
        <a href="/post/about" class="menu">
          å…³äº
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              ç”¨ChatGPTå¼€å‘ä¸€ä¸ªæ™ºèƒ½èœœç½
            </h2>
            <div class="post-info">
              <span>
                2023-05-06
              </span>
              <span>
                19 min read
              </span>
              
                <a href="https://skyblu3519.github.io/tag/B8Ad4Cpsd/" class="post-tag">
                  # ChatGPT
                </a>
              
                <a href="https://skyblu3519.github.io/tag/Wx6_y2u_LL/" class="post-tag">
                  # èœœç½
                </a>
              
                <a href="https://skyblu3519.github.io/tag/C5fsAn1wpc/" class="post-tag">
                  # Prompt Engineering
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://skyblu3519.github.io/post-images/yong-chatgpt-kai-fa-yi-ge-zhi-neng-mi-guan-sheng-cheng-xi-tong.jpeg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>æ¥ç”¨ChatGPTåšä¸ªèœœç½ï¼Œhave fun~ğŸ˜</p>
<h1 id="æç¤ºè¯å·¥ç¨‹prompt-engineering">æç¤ºè¯å·¥ç¨‹ï¼ˆPrompt Engineeringï¼‰</h1>
<p>æ•™ç¨‹BVå·ï¼šBV1No4y1t7Zn</p>
<p>ç¼–å†™åŸåˆ™ï¼š</p>
<ul>
<li>ç¼–å†™æ˜ç¡®å’Œå…·ä½“çš„æŒ‡ä»¤</li>
<li>ç»™æ¨¡å‹è¶³å¤Ÿçš„æ—¶é—´æ€è€ƒ</li>
</ul>
<p>ä¸€ä¸ªPromptçš„æ ·ä¾‹ï¼š</p>
<pre><code class="language-python">import openai

openai.api_key = 'sk-'      # OpenAI API Key

def get_completion(prompt, model=&quot;gpt-3.5-turbo&quot;):
	messages = [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}]
	response = openai.ChatCompletion.create(
		model=model,
		messages=messages,
		temperature=0,
		)
	return response.choices[0].message[&quot;content&quot;]

prompt = &quot;&quot;     # æé—®
response = get_completion(prompt)
print(response)
</code></pre>
<h1 id="ç›´æ¥æ¥å§">ç›´æ¥æ¥å§ï¼</h1>
<p>å…ˆåœ¨ç½‘é¡µæµ‹è¯•æ•´ä¸ªæµç¨‹ã€‚</p>
<h2 id="å…ˆåšä¸ªdemo">å…ˆåšä¸ªDemo</h2>
<h3 id="ç¬¬ä¸€è½®æé—®">ç¬¬ä¸€è½®æé—®</h3>
<p>å…ˆç›´æ¥ç”Ÿæˆä¸€äº›ç®€å•çš„çš„çœ‹çœ‹æ•ˆæœã€‚<br>
<img src="https://skyblu3519.github.io/post-images/1683379900218.jpg" alt="" loading="lazy"></p>
<p>ä¸­æ–‡promptï¼š</p>
<pre><code class="language-php">æˆ‘éœ€è¦ç”¨dockeråšä¸€äº›èœœç½ã€‚ä½ åœ¨åšè¿™ä»¶äº‹å¯ä»¥ä»ä»¥ä¸‹å‡ ä¸ªå†…å®¹è€ƒè™‘ï¼š
- æ€ä¹ˆæ ·çš„ç½‘ç»œè®¾ç½®å¯ä»¥è®©èœœç½è¢«åŒä¸€ä¸ªç½‘ç»œä¸­çš„ä¸»æœºè®¿é—®ã€‚
- æ„å»ºèœœç½çš„dockerfileéœ€è¦æŒ‰è§„å¾‹çš„ä¿å­˜ã€‚æœ€å¥½ä¸ºæ¯ä¸ªèœœç½åˆ›å»ºä¸€ä¸ªå¯¹åº”çš„æ–‡ä»¶å¤¹ï¼Œä¸€ä¸ªæ–‡ä»¶å¤¹å­˜æ”¾ä¸€ä¸ªèœœç½çš„dockerfileã€‚
- ç°åœ¨èœœç½ä¸Šä¸ä¼šè¿è¡Œä»»ä½•æœåŠ¡ï¼Œå®ƒåªç”¨å¯¹ç±»ä¼¼pingè¿™æ ·çš„å‘½ä»¤åšåº”ç­”å³å¯ã€‚
- è¿™æ ·çš„èœœç½æˆ‘éœ€è¦ä¸€æ¬¡ç”Ÿæˆå¤šä¸ªï¼Œæ‰€ä»¥ä½ éœ€è¦è€ƒè™‘æ€ä¹ˆè®¾ç½®IPæ¥é¿å…ä¸ç½‘ç»œä¸Šå·²ç»å­˜åœ¨çš„çœŸå®ä¸»æœºå†²çªã€‚
- èœœç½æ‰€åœ¨ç½‘æ®µä¸º10.211.55.0/255
ä½ å¯ä»¥å†™ä¸€ä¸ªpythonè„šæœ¬æ¥å®Œæˆä¸Šé¢çš„å·¥ä½œã€‚
</code></pre>
<p>ç¿»è¯‘ï¼š</p>
<pre><code>I need to make some honeypots with docker. Here are a few things you can consider when doing this:
- What kind of network settings allow the honeypot to be accessed by hosts in the same network.
- The dockerfile for building the honeypot needs to be saved regularly. It is best to create a corresponding folder for each honeypot, and a folder stores the dockerfile of a honeypot.
- Now there is no service running on the honeypot, it just responds to commands like ping.
- I need to generate multiple such honeypots at a time, so you need to consider how to set the IP to avoid conflicts with real hosts that already exist on the network.
- The network segment where the honeypot is located is 10.211.55.0/255
You can write a python script to do the above.
</code></pre>
<p>ChatGPTï¼š</p>
<pre><code class="language-python">import os

# Define the base IP address for the honeypots
base_ip = &quot;10.211.55.&quot;

# Define the number of honeypots to create
num_honeypots = 5

# Define the path to the directory where the Dockerfiles will be stored
dockerfiles_dir = &quot;/path/to/dockerfiles&quot;

# Loop through each honeypot and create a Dockerfile and container for it
for i in range(num_honeypots):
    # Define the IP address for the current honeypot
    ip_address = base_ip + str(i+1)

    # Create a directory for the current honeypot's Dockerfile
    honeypot_dir = os.path.join(dockerfiles_dir, &quot;honeypot_&quot; + str(i+1))
    os.makedirs(honeypot_dir, exist_ok=True)

    # Write the Dockerfile for the current honeypot
    with open(os.path.join(honeypot_dir, &quot;Dockerfile&quot;), &quot;w&quot;) as f:
        f.write(f&quot;FROM alpine\n&quot;)
        f.write(f&quot;RUN apk add --no-cache bash\n&quot;)
        f.write(f&quot;CMD [\&quot;bash\&quot;]\n&quot;)

    # Build the Docker image for the current honeypot
    os.system(f&quot;docker build -t honeypot_{i+1} {honeypot_dir}&quot;)

    # Run the Docker container for the current honeypot
    os.system(f&quot;docker run --name honeypot_{i+1} --ip {ip_address} --network honeypot_net -d honeypot_{i+1}&quot;)

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://skyblu3519.github.io/post-images/1683379937826.jpg" alt="" loading="lazy"></figure>
<p>åˆ†æï¼š<br>
ä¸¤ä¸ªé—®é¢˜</p>
<ul>
<li>IPè®¾ç½®æ²¡æœ‰è€ƒè™‘å†²çª</li>
<li>è¿è¡Œdockerä¸­çš„network honeypot_netæ²¡æœ‰è®¾ç½®</li>
</ul>
<h3 id="è¿­ä»£1">è¿­ä»£1</h3>
<p>ä¸€ä¸ªä¸€ä¸ªè§£å†³ï¼Œé¦–å…ˆæ˜¯network honeypot_netçš„è®¾ç½®ã€‚</p>
<p>ä¸­æ–‡promptï¼š</p>
<pre><code>ä¸Šé¢ä½ æ‰€ç”¨çš„network 'honeypot_net' å¹¶æ²¡æœ‰è®¾ç½®ï¼Œè¯·åœ¨ä»£ç ä¸­æ·»åŠ ä¸€ä¸ªå‡½æ•°å®Œæˆè¿™ä¸€åŠŸèƒ½ã€‚

è¿™ä¸ªåŠŸèƒ½ä½ å¯ä»¥ä»ä¸‹é¢å‡ ç‚¹è€ƒè™‘ï¼š
- è®¾ç½®ä¸€ä¸ªdockerçš„macvlanç½‘ç»œ
- è®¾ç½®çš„æ—¶å€™çœ‹å½“å‰çš„ç½‘ç»œä¸­æ˜¯å¦å·²ç»æœ‰ç¬¦åˆè¦æ±‚çš„ç½‘ç»œè®¾ç½®
- è¿è¡Œdockerçš„ç‰©ç†ä¸»æœºçš„ç½‘å¡åç§°ä¸º'eth0'
</code></pre>
<p>ç¿»è¯‘ï¼š</p>
<pre><code>The network 'honeypot_net' you used above is not set, please add a function to the code to complete this function.

You can consider the following points for this function:
- Set up a docker macvlan network
- When setting, check whether there is already a network setting that meets the requirements in the current network
- The NIC name of the physical host running docker is 'eth0'
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://skyblu3519.github.io/post-images/1683379983444.jpg" alt="" loading="lazy"></figure>
<p>ChatGPTï¼š</p>
<pre><code class="language-python">import os

# Define the base IP address for the honeypots
base_ip = &quot;10.211.55.&quot;

# Define the number of honeypots to create
num_honeypots = 5

# Define the path to the directory where the Dockerfiles will be stored
dockerfiles_dir = &quot;/path/to/dockerfiles&quot;

# Define the name and subnet of the Docker network
network_name = &quot;honeypot_net&quot;
network_subnet = &quot;10.211.55.0/24&quot;

# Check if the network already exists
network_exists = os.system(f&quot;docker network inspect {network_name} &gt;/dev/null 2&gt;&amp;1&quot;) == 0

# Create the network if it doesn't exist
if not network_exists:
    os.system(f&quot;docker network create --driver macvlan --subnet {network_subnet} --gateway {base_ip}1 -o parent=eth0 {network_name}&quot;)

# Loop through each honeypot and create a Dockerfile and container for it
for i in range(num_honeypots):
    # Define the IP address for the current honeypot
    ip_address = base_ip + str(i+1)

    # Create a directory for the current honeypot's Dockerfile
    honeypot_dir = os.path.join(dockerfiles_dir, &quot;honeypot_&quot; + str(i+1))
    os.makedirs(honeypot_dir, exist_ok=True)

    # Write the Dockerfile for the current honeypot
    with open(os.path.join(honeypot_dir, &quot;Dockerfile&quot;), &quot;w&quot;) as f:
        f.write(f&quot;FROM alpine\n&quot;)
        f.write(f&quot;RUN apk add --no-cache bash\n&quot;)
        f.write(f&quot;CMD [\&quot;bash\&quot;]\n&quot;)

    # Build the Docker image for the current honeypot
    os.system(f&quot;docker build -t honeypot_{i+1} {honeypot_dir}&quot;)

    # Run the Docker container for the current honeypot, connecting it to the network
    os.system(f&quot;docker run --name honeypot_{i+1} --ip {ip_address} --network {network_name} -d honeypot_{i+1}&quot;)

</code></pre>
<figure data-type="image" tabindex="3"><img src="https://skyblu3519.github.io/post-images/1683380005168.jpg" alt="" loading="lazy"></figure>
<p>ä¿®æ”¹dockerfileçš„ä¿å­˜è·¯å¾„<code>/home/hp/dockerfiles</code>å’Œèœœç½IP<br>
<img src="https://skyblu3519.github.io/post-images/1683380025229.jpg" alt="" loading="lazy"><br>
è¿è¡Œï¼ŒæˆåŠŸå¯åŠ¨äº†5ä¸ªèœœç½ã€‚<br>
<img src="https://skyblu3519.github.io/post-images/1683380062027.jpg" alt="" loading="lazy"><br>
ç„¶è€Œè¿™äº”ä¸ªèœœç½æ— æ³•pingé€š</p>
<h3 id="è¿­ä»£2">è¿­ä»£2</h3>
<p>ç›´æ¥è¯¢é—®æ— æ³•pingé€šçš„åŸå› <br>
<img src="https://skyblu3519.github.io/post-images/1683380080744.jpg" alt="" loading="lazy"><br>
å¹¶æ²¡æœ‰æ‰¾åˆ°é—®é¢˜çš„æ ¸å¿ƒ</p>
<p>æé—®ï¼š</p>
<pre><code>æˆ‘è®¤ä¸ºèœœç½æ— æ³•pingé€šå¹¶ä¸æ˜¯cap-add=NET_ADMINçš„åŸå› ï¼Œæˆ‘ç”¨docker ps -aå‘½ä»¤æŸ¥çœ‹å®¹å™¨çŠ¶æ€çš„æ—¶å€™æ˜¾ç¤ºçš„ä¿¡æ¯ä¸ºâ€˜Exited (0) 12 seconds agoâ€™ï¼Œæˆ‘è®¤ä¸ºè¿™ä¸ªåŸå› åº”è¯¥æ˜¯dockerfileå¯¼è‡´çš„ã€‚
</code></pre>
<p>ç¿»è¯‘ï¼š</p>
<pre><code>I don't think the honeypot can't be pinged because of cap-add=NET_ADMIN. When I use the docker ps -a command to check the container status, the information displayed is 'Exited (0) 12 seconds ago'. I think the reason should be the dockerfile caused by.
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://skyblu3519.github.io/post-images/1683380132720.jpg" alt="" loading="lazy"></figure>
<p>å¯¼è‡´è¿™ä¸ªçš„åŸå› æ˜¯å› ä¸ºä¹‹å‰çš„dockerè¿è¡Œä¸€è¡Œå‘½ä»¤å°±é€€å‡ºäº†ï¼Œæ·»åŠ è¿™ä¸€è¡Œåœ¨ç”Ÿæˆdockerfileçš„éƒ¨åˆ†ï¼š<br>
<img src="https://skyblu3519.github.io/post-images/1683380294241.jpg" alt="" loading="lazy"></p>
<p>æˆåŠŸç”Ÿæˆäº†æƒ³è¦çš„èœœç½ï¼š<br>
<img src="https://skyblu3519.github.io/post-images/1683380326664.jpg" alt="" loading="lazy"></p>
<p>pingæµ‹è¯•ï¼š<br>
<img src="https://skyblu3519.github.io/post-images/1683380351106.jpg" alt="" loading="lazy"></p>
<p>dockerfilesç›®å½•ç»“æ„<br>
<img src="https://skyblu3519.github.io/post-images/1683380374987.jpg" alt="" loading="lazy"></p>
<p>è‡³äºç¬¬ä¸€ä¸ªIPå†²çªé—®é¢˜åœ¨è¿™å„¿å…ˆä¸ç®¡äº†ï¼Œæ„Ÿè§‰åœ¨è¿™å„¿åšä¹Ÿæ˜¯é‡å¤é€ è½®å­ã€‚ä¸å¦‚åŠ ä¸€ç‚¹æ™ºèƒ½ï¼</p>
<h2 id="æ¥ç‚¹æ™ºèƒ½">æ¥ç‚¹æ™ºèƒ½ï¼</h2>
<p>è™½ç„¶å†™äº†ç‚¹ä¸œè¥¿ï¼Œä½†æ˜¯æ€»æ„Ÿè§‰å·®ç‚¹â€œæ™ºèƒ½â€ã€‚æ¯•ç«Ÿè¿™äº›ä»£ç è‡ªå·±ä¹Ÿå¯ä»¥å†™ï¼Œä½•å¿…è¦ç”¨GPTå†™çš„å‘¢ï¼Ÿæœ€å¥½çš„æ–¹æ³•æ˜¯è®©GPTå‚ä¸åˆ°è¿™ä¸ªç”Ÿæˆè¿‡ç¨‹é‡Œï¼Œè€Œä¸æ˜¯æ‰®æ¼”ä¸€ä¸ªæä¾›ä»£ç çš„è§’è‰²ã€‚</p>
<p>é‚£ä¹ˆGPTå¯ä»¥åšä»€ä¹ˆå‘¢ï¼Ÿæ—¢ç„¶æ˜¯ç”Ÿæˆå¼AIï¼Œé‚£ä¹ˆå°±è®©å®ƒæ¥ç”Ÿæˆä¸åŒçš„èœœç½ç±»å‹ã€‚</p>
<p>äºæ˜¯å°è¯•ç”¨gptæ¥æ™ºèƒ½ç”Ÿæˆdockerfileï¼Œç¼–å†™ä»¥ä¸€ä¸ªpromptæ¨¡ç‰ˆæ¥çš„ç”Ÿæˆä¸åŒçš„èœœç½ç±»å‹ã€‚</p>
<p>ä¸­æ–‡ï¼š</p>
<pre><code class="language-python">æŒ‰æ‰¾éœ€æ±‚ç¼–å†™ä¸€ä¸ªdockerfileï¼Œè¿™ä¸ªdockerfileç”¨äºç”Ÿæˆä¸€ä¸ªé•œåƒã€‚

éœ€æ±‚çš„æ ¼å¼ä¸ºï¼š
- éƒ¨ç½²çš„æœåŠ¡1: æœåŠ¡æè¿°1,  æœåŠ¡æè¿°2

å¯¹äºæ²¡æœ‰æœåŠ¡æè¿°çš„æœåŠ¡ä½ å¯ä»¥è‡ªè¡Œåˆ¤æ–­ï¼Œä¸‹é¢æ˜¯æˆ‘çš„éœ€æ±‚ï¼š
</code></pre>
<p>è‹±æ–‡ï¼š</p>
<pre><code class="language-python">Write a dockerfile according to the requirements, and this dockerfile is used to generate a mirror image.

The required format is:
- Deployed Service 1: Service Description 1, Service Description 2

For services without service descriptions, you can judge by yourself. The following are my requirements:
</code></pre>
<p>æå‡ºçš„æœåŠ¡éœ€æ±‚éšæœºç»„åˆï¼Œè¿™é‡Œç®€å•å‡†å¤‡äº†ä¸¤ä¸ªæœåŠ¡Apacheå’ŒNginxï¼Œå¯¹æ¯ä¸ªæœåŠ¡æœ‰ä¸¤ä¸ªæè¿°ç«¯å£å’Œé¡µé¢ä¿¡æ¯ï¼š</p>
<pre><code class="language-python">import random

def random_combine_lists(product, port, detail, num=1):
    result = []
    for i in range(num):
        combined_string = &quot;- {}: {}, {}&quot;.format(random.choice(product), random.choice(port), random.choice(detail))
        result.append(combined_string)
    return result


product = ['Apache', 'nginx']
port = ['This service runs on port 80', 'This service runs on port 8080']
detail = ['Display a 404 page by default', 'Display a background login page by default',]

result = random_combine_lists(product, port, detail)
service = result[0]
</code></pre>
<p>åœ¨ä»£ç ä¸­å®ç°ï¼š</p>
<pre><code class="language-python">import openai

openai.api_key = '' # è¾“å…¥è‡ªå·±çš„api_key

def get_completion(prompt, model=&quot;gpt-3.5-turbo&quot;):
	messages = [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}]
	response = openai.ChatCompletion.create(
		model=model,
		messages=messages,
		temperature=0,
		)
	return response.choices[0].message[&quot;content&quot;]

import random

def random_combine_lists(product, port, detail, num=1):
    result = []
    for i in range(num):
        combined_string = &quot;- {}: {}, {}&quot;.format(random.choice(product), random.choice(port), random.choice(detail))
        result.append(combined_string)
    return result


product = ['Apache', 'nginx']
port = ['This service runs on port 80', 'This service runs on port 8080']
detail = ['Display a 404 page by default', 'Display a background login page by default']

result = random_combine_lists(product, port, detail)

service = result[0]

prompt = f&quot;&quot;&quot;Write a dockerfile according to the requirements, and this dockerfile is used to generate a mirror image.

The required format is:
- Deployed Service 1: Service Description 1, Service Description 2

For services without service descriptions, you can judge by yourself. The following are my requirements:
{service}
&quot;&quot;&quot;
# print(prompt)
response = get_completion(prompt)
print(response)

</code></pre>
<p>ä¹ä¸€çœ‹æ•ˆæœè¿˜ä¸é”™ï¼Ÿï¼ˆä½†å…¶å®æœ‰å¤§é—®é¢˜<br>
<img src="https://skyblu3519.github.io/post-images/1683380691345.jpg" alt="" loading="lazy"></p>
<p>ä¸è¿‡å…ˆä¸ç®¡ï¼Œç®€å•å°è£…ä¸€ä¸‹ä¸ä¹‹å‰çš„ä»£ç è¿›è¡Œç»„åˆï¼šhoneypottest.py</p>
<pre><code class="language-python">import os
from gpt import honey_gpt
base_ip = &quot;10.211.55.&quot;

num_honeypots = 3

dockerfiles_dir = &quot;/home/hp/dockerfiles&quot;

network_name = &quot;honeypot_net&quot;
network_subnet = &quot;10.211.55.0/24&quot;

network_exists = os.system(&quot;docker network inspect {} &gt;/dev/null 2&gt;&amp;1&quot;.format(network_name)) == 0

if not network_exists:
    os.system(&quot;docker network create --driver macvlan --subnet {} --gateway {}1 -o parent=eth0 {}&quot;.format(network_subnet, base_ip, network_name))


for i in range(num_honeypots):
    ip_address = base_ip + str(i+128)
    honeypot_dir = os.path.join(dockerfiles_dir, &quot;honeypot_&quot; + str(i+1))
    os.makedirs(honeypot_dir, exist_ok=True)

    with open(os.path.join(honeypot_dir, &quot;Dockerfile&quot;), &quot;w&quot;) as f:
        f.write(honey_gpt())

    os.system(&quot;docker build -t honeypot_{} {}&quot;.format(i+1, honeypot_dir))
    os.system(&quot;docker run --name honeypot_{} --ip {} --network {} -d honeypot_{}&quot;.format(i+1, ip_address, network_name, i+1))


</code></pre>
<p>gpt.py</p>
<pre><code class="language-python">import openai
import random

openai.api_key = 'sk-'

def get_completion(prompt, model=&quot;gpt-3.5-turbo&quot;):
	messages = [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}]
	response = openai.ChatCompletion.create(
		model=model,
		messages=messages,
		temperature=0,
		)
	return response.choices[0].message[&quot;content&quot;]

def random_combine_lists(product, port, detail, num=1):
    result = []
    for i in range(num):
        combined_string = &quot;- {}: {}, {}&quot;.format(random.choice(product), random.choice(port), random.choice(detail))
        result.append(combined_string)
    return result


def honey_gpt():
	product = ['Apache', 'nginx']
	port = ['This service runs on port 80', 'This service runs on port 8080']
	detail = ['Display a 404 page by default', 'Display a background login page by default']

	result = random_combine_lists(product, port, detail)

	service = result[0]

	prompt = f&quot;&quot;&quot;Write a dockerfile according to the requirements, and this dockerfile is used to generate a mirror image.

	The required format is:
	- Deployed Service 1: Service Description 1, Service Description 2

	For services without service descriptions, you can judge by yourself. The following are my requirements:
	{service}
	&quot;&quot;&quot;
	print(service)
	response = get_completion(prompt)
	return response

</code></pre>
<p>é—®é¢˜æ¥äº†<br>
<img src="https://skyblu3519.github.io/post-images/1683380716362.jpg" alt="" loading="lazy"></p>
<p>æ‰€æœ‰æœåŠ¡éƒ½ä¸èƒ½è®¿é—®ï¼Œçœ‹ä¸‹dockerfile<br>
<img src="https://skyblu3519.github.io/post-images/1683380731817.jpg" alt="" loading="lazy"></p>
<p>è¿™é‡Œcopyæœ¬æœºä¸å­˜åœ¨çš„æ–‡ä»¶ï¼Œæ—¢ç„¶éƒ½æ™ºèƒ½äº†è¿™äº›ä¸œè¥¿å°±ç»™gptåšäº†ã€‚ä¿®æ”¹ä¸‹prompt</p>
<pre><code>æŒ‰æ‰¾éœ€æ±‚ç¼–å†™ä¸€ä¸ªdockerfileï¼Œè¿™ä¸ªdockerfileç”¨äºç”Ÿæˆä¸€ä¸ªé•œåƒã€‚

éœ€æ±‚çš„æ ¼å¼ä¸ºï¼š
- éƒ¨ç½²çš„æœåŠ¡1: æœåŠ¡æè¿°1, æœåŠ¡æè¿°2

å¯¹äºæ²¡æœ‰æœåŠ¡æè¿°çš„æœåŠ¡ä½ å¯ä»¥è‡ªè¡Œåˆ¤æ–­ã€‚

è¿™äº›éœ€æ±‚åªèƒ½åœ¨dockerfileä¸­å®ç°ï¼Œç‰©ç†æœºä¸­æ²¡æœ‰ç”¨æ¥å¯ç”¨çš„ä»»ä½•æ–‡ä»¶ã€‚éœ€æ±‚å¦‚ä¸‹ï¼š
</code></pre>
<p>è‹±æ–‡ï¼š</p>
<pre><code>Write a dockerfile according to the requirements, and this dockerfile is used to generate a mirror image.

The required format is:
- Deployed Service 1: Service Description 1, Service Description 2

For services without service descriptions, you can judge by yourself. 

These requirements can only be realized in the dockerfile, and there are no available files in the physical machine. The requirements are as follows:
</code></pre>
<p>ç”Ÿæˆçš„dockerfileä¾ç„¶åœ¨ç”¨COPY<br>
<img src="https://skyblu3519.github.io/post-images/1683380828502.jpg" alt="" loading="lazy"></p>
<p>æ˜ç¡®ä¸è¦ä½¿ç”¨COPYï¼Œè¿½åŠ promptï¼š<code>å› æ­¤ï¼Œä½ æ— æ³•ä½¿ç”¨COPYæ¥å°†ç‰©ç†æœºä¸­æ–‡ä»¶å¤åˆ¶åˆ°å®¹å™¨ä¸­ã€‚</code></p>
<pre><code>Write a dockerfile according to the requirements, and this dockerfile is used to generate a mirror image.

The required format is:
- Service 1: Description 1, Description 2

For services without descriptions, you can judge by yourself. 

These requirements can only be realized in the dockerfile, and there are no available files in the physical machine. Therefore, you cannot use COPY to copy files from the physical machine to the container.

The requirements are as follows:
</code></pre>
<p>æ„Ÿè§‰å¥½äº›äº†<br>
<img src="https://skyblu3519.github.io/post-images/1683380919396.jpg" alt="" loading="lazy"></p>
<p>é‡æ–°è¿è¡Œä¸‹ã€‚ç„¶è€Œå¹¶ä¸å¤ªè¡Œï¼Œå³ä½¿è¯´æ˜ä¸è¦ä½¿ç”¨<code>COPY</code>ã€‚å®ƒå†™çš„dockerfileè¿˜æ˜¯æœ‰æ¦‚ç‡å‡ºç°COPYã€‚æ€€ç–‘æ˜¯ä¸­é—´é‚£å¥<code>you can judge by yourself</code>æœ‰å¹²æ‰°ï¼Œå…ˆåˆ äº†ã€‚</p>
<p>å†åŠ ä¸€å¥ï¼š<code>å¦‚æœä½ éœ€è¦å¤åˆ¶ä¸€ä¸ªæ–‡ä»¶åˆ°å®¹å™¨ä¸­ï¼Œä½ å¯ä½¿ç”¨sedåœ¨å·²æœ‰æ–‡ä»¶ä¸­æ’å…¥ï¼Œæˆ–è€…ä½¿ç”¨echoç›´æ¥å°†å†…å®¹è¾“å‡ºåˆ°æ–‡ä»¶ä¸­ã€‚</code>æ›´æ–°åçš„promptï¼š</p>
<pre><code class="language-python">prompt = f&quot;&quot;&quot;Write a dockerfile according to the requirements, and this dockerfile is used to generate a mirror image.

The required format is:
- Service 1: Description 1, Description 2

Because you don't know what files exist on the physical machine, it is imperative that you DO NOT use the COPY instruction when writing the Dockerfile!

If you need to copy a file into the container, you can use sed to insert it into an existing file, or use echo to output the contents directly into a file.

The requirements are as follows:
{service}
&quot;&quot;&quot;
</code></pre>
<p>è¿™ä¸ªpromptåï¼Œè¾“å‡ºå‡ æ¬¡åä¼¼ä¹æ˜¯æ²¡æœ‰ç”¨COPYäº†ï¼Œä½†æ˜¯åœ¨ä¸åŒç«¯å£æš´éœ²æœåŠ¡ä¼¼ä¹æœ‰é—®é¢˜ï¼Œå‰é¢çŸ¥é“æˆ‘è¿™é‡Œç”¨äº†ä¸‰ä¸ªåˆ—è¡¨æ¥ç»„åˆä¸€ä¸ªè¦æ±‚ï¼Œåœ¨<code>product</code>å’Œ<code>port</code>ç›¸åŒçš„æƒ…å†µä¸‹ï¼Œä¸åŒçš„<code>detail</code>å±…ç„¶ä¼šå†™å‡ºå¤æ‚åº¦ä¸¤ç§å®Œå…¨ä¸åŒçš„dockerfileã€‚æ˜¾ç„¶ç¬¬ä¸€ä¸ªæ— æ³•å°†æœåŠ¡æš´éœ²åœ¨8080ä¸Šã€‚</p>
<pre><code class="language-python">product = ['Apache', 'nginx']
port = ['This service runs on port 80', 'This service runs on port 8080']
detail = ['Return 404 for all requests', 'Display a background login page']
</code></pre>
<p><img src="https://skyblu3519.github.io/post-images/1683380958561.jpg" alt="" loading="lazy"><br>
ç°åœ¨æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ€€ç–‘æ˜¯<code>Display a background login page</code>è¿™ç§è¡¨è¿°æœ‰ç‚¹æ¨¡ç³Šã€‚</p>
<p>å¯¹detailä¸­æè¿°è¿›è¡Œè¿›ä¸€æ­¥çš„ç»†åŒ–<code>Replace the default page with a login page.</code></p>
<p>ç„¶è€Œå¹¶ä¸èƒ½è§£å†³é—®é¢˜ã€‚è½¬å‘<code>port</code>çš„è¡¨è¿°ã€‚</p>
<h3 id="æœåŠ¡ç»„åˆé’ˆå¯¹æµ‹è¯•">æœåŠ¡ç»„åˆé’ˆå¯¹æµ‹è¯•</h3>
<p>ä¸¤ä¸ªwebæœåŠ¡éƒ½æš´éœ²åœ¨8080ç«¯å£ä¸Šï¼Œéƒ½ç”¨ä¸€ä¸ªç™»å½•é¡µé¢ä½œä¸ºé»˜è®¤é¡µé¢çš„ä»£æ›¿ã€‚</p>
<pre><code class="language-python">product = ['Apache', 'nginx']
port = ['This service runs on port 8080']
detail = ['Replace the default page with a login page']
</code></pre>
<p>ç”Ÿæˆçš„3ä¸ªdockerfileè™½ç„¶éƒ½æ˜¯ä¸€ä¸ªå¾ˆè ¢çš„é¡µé¢ï¼Œä½†ç”¨Apacheç»„åˆçš„è‡³å°‘ç«¯å£å¯¹äº†ï¼Œnginxè¿ç«¯å£éƒ½æ²¡å¯¹ä¸Šã€‚<br>
<img src="https://skyblu3519.github.io/post-images/1683381094388.jpg" alt="" loading="lazy"></p>
<p>ä¿®æ”¹ä¸€ä¸‹portçš„æè¿°ï¼š<code>This service needs to be exposed on port 8080</code><br>
<img src="https://skyblu3519.github.io/post-images/1683381115008.jpg" alt="" loading="lazy"><br>
æ›´ç®€é™‹äº†ï¼Œè¿™æ¬¡è¿nginxéƒ½æ²¡æœ‰è¿è¡Œ</p>
<p><code>This service can be accessed through port 8080</code><br>
<img src="https://skyblu3519.github.io/post-images/1683381139057.jpg" alt="" loading="lazy"></p>
<p>æœäº†ä¸€ä¸‹ï¼Œå‘ç°è‹±è¯­åœ¨åšè¿™ä»¶äº‹çš„æ—¶å€™ï¼Œå¤šç”¨çš„è¡¨è¿°ä¸º<code>listen</code>ã€‚ä¿®æ”¹promptï¼š<code>This service is listening on port 8080.</code><br>
<img src="https://skyblu3519.github.io/post-images/1683381152491.jpg" alt="" loading="lazy"></p>
<p>æå®šï½<br>
<img src="https://skyblu3519.github.io/post-images/1683381175495.jpg" alt="" loading="lazy"></p>
<p>ä¸¤ä¸ªçš„404é¡µé¢ä¹Ÿæ²¡æœ‰ä»€ä¹ˆé—®é¢˜<br>
<img src="https://skyblu3519.github.io/post-images/1683381192034.jpg" alt="" loading="lazy"><br>
<img src="https://skyblu3519.github.io/post-images/1683381198852.jpg" alt="" loading="lazy"></p>
<h1 id="æ€»ç»“">æ€»ç»“</h1>
<p>ç®—ç®€å•åšäº†ä¸ªpromptå®éªŒï¼Œè¿™ç§è¿˜æ˜¯åªæœ‰ä¸æ–­è¯•æ‰èƒ½æ‰¾åˆ°ä¸ªæ¯”è¾ƒç†æƒ³çš„ã€‚</p>
<p>ç›®å‰è¿™èœœç½ä¸ªè¿˜æ˜¯è¿‡äºç®€é™‹äº†ï¼Œè™½ç„¶çœŸå®ç›¸æ¯”å·®çš„è¿˜æŒºå¤§ï¼Œä¸è¿‡æ„Ÿè§‰GPTåšè¿™ä¸ªè¿˜æ˜¯æœ‰ç‚¹æ½œåŠ›çš„ã€‚</p>
<p>æœ€åè®°ä¸‹æœ€ç»ˆç‰ˆä»£ç ï¼š<br>
gpt.py</p>
<pre><code class="language-python">import openai
import random

openai.api_key = 'sk-'

def get_completion(prompt, model=&quot;gpt-3.5-turbo&quot;):
	messages = [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}]
	response = openai.ChatCompletion.create(
		model=model,
		messages=messages,
		temperature=0,
		)
	return response.choices[0].message[&quot;content&quot;]

def random_combine_lists(product, port, detail, num=1):
    result = []
    for i in range(num):
        combined_string = &quot;- {}: {}, {}&quot;.format(random.choice(product), random.choice(port), random.choice(detail))
        result.append(combined_string)
    return result


def honey_gpt():
	product = ['Apache', 'Nginx']
	port = ['This service listens on port 80','This service listens on port 8080']
	detail = ['Return 404 for all requests', 'This service listens on port 8080']#, 'Replace the default page with a login page'

	result = random_combine_lists(product, port, detail)

	service = result[0]

	prompt = f&quot;&quot;&quot;Write a dockerfile according to the requirements, and this dockerfile is used to generate a mirror image.

	The required format is:
	- Service 1: Description 1, Description 2

	Because you don't know what files exist on the physical machine, it is imperative that you DO NOT use the COPY instruction when writing the Dockerfile!
	
	
	If you need to copy a file into the container, you can use sed to insert it into an existing file, or use echo to output the contents directly into a file.

	The requirements are as follows:
	{service}
	&quot;&quot;&quot;
	# print(service)
	response = get_completion(prompt)
	print(response)
	return response

if __name__ == &quot;__main__&quot;:
	honey_gpt()
</code></pre>
<p>honeygpt.py</p>
<pre><code class="language-python">import os
from gpt import honey_gpt
base_ip = &quot;10.211.55.&quot;

num_honeypots = 3

dockerfiles_dir = &quot;/home/hp/dockerfiles&quot;

network_name = &quot;honeypot_net&quot;
network_subnet = &quot;10.211.55.0/24&quot;

network_exists = os.system(&quot;docker network inspect {} &gt;/dev/null 2&gt;&amp;1&quot;.format(network_name)) == 0

if not network_exists:
    os.system(&quot;docker network create --driver macvlan --subnet {} --gateway {}1 -o parent=eth0 {}&quot;.format(network_subnet, base_ip, network_name))


for i in range(num_honeypots):
    ip_address = base_ip + str(i+128)
    honeypot_dir = os.path.join(dockerfiles_dir, &quot;honeypot_&quot; + str(i+1))
    os.makedirs(honeypot_dir, exist_ok=True)

    with open(os.path.join(honeypot_dir, &quot;Dockerfile&quot;), &quot;w&quot;) as f:
        f.write(honey_gpt())

    os.system(&quot;docker build -t honeypot_{} {}&quot;.format(i+1, honeypot_dir))
    os.system(&quot;docker run --name honeypot_{} --ip {} --network {} -d honeypot_{}&quot;.format(i+1, ip_address, network_name, i+1))
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8Bprompt-engineering">æç¤ºè¯å·¥ç¨‹ï¼ˆPrompt Engineeringï¼‰</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E6%9D%A5%E5%90%A7">ç›´æ¥æ¥å§ï¼</a>
<ul>
<li><a href="#%E5%85%88%E5%81%9A%E4%B8%AAdemo">å…ˆåšä¸ªDemo</a>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E8%BD%AE%E6%8F%90%E9%97%AE">ç¬¬ä¸€è½®æé—®</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A31">è¿­ä»£1</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A32">è¿­ä»£2</a></li>
</ul>
</li>
<li><a href="#%E6%9D%A5%E7%82%B9%E6%99%BA%E8%83%BD">æ¥ç‚¹æ™ºèƒ½ï¼</a>
<ul>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%BB%84%E5%90%88%E9%92%88%E5%AF%B9%E6%B5%8B%E8%AF%95">æœåŠ¡ç»„åˆé’ˆå¯¹æµ‹è¯•</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">æ€»ç»“</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">ä¸‹ä¸€ç¯‡</div>
            <a href="https://skyblu3519.github.io/post/jia-qi-jie-shu-liao/">
              <h3 class="post-title">
                å‡æœŸç»“æŸäº†......
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://skyblu3519.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
